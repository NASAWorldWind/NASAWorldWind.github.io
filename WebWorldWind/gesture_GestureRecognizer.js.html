<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WorldWind: Source: gesture/GestureRecognizer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: gesture/GestureRecognizer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2003-2006, 2009, 2017, 2020 United States Government, as represented
 * by the Administrator of the National Aeronautics and Space Administration.
 * All rights reserved.
 *
 * The NASAWorldWind/WebWorldWind platform is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License
 * at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * NASAWorldWind/WebWorldWind also contains the following 3rd party Open Source
 * software:
 *
 *    ES6-Promise – under MIT License
 *    libtess.js – SGI Free Software License B
 *    Proj4 – under MIT License
 *    JSZip – under MIT License
 *
 * A complete listing of 3rd Party software notices and licenses included in
 * WebWorldWind can be found in the WebWorldWind 3rd-party notices and licenses
 * PDF found in code  directory.
 */
/**
 * @exports GestureRecognizer
 */
define([
        '../error/ArgumentError',
        '../util/Logger',
        '../gesture/Touch'
    ],
    function (ArgumentError,
              Logger,
              Touch) {
        "use strict";

        /**
         * Constructs a base gesture recognizer. This is an abstract base class and not intended to be instantiated
         * directly.
         * @alias GestureRecognizer
         * @constructor
         * @classdesc Gesture recognizers translate user input event streams into higher level actions. A gesture
         * recognizer is associated with an event target, which dispatches mouse and keyboard events to the gesture
         * recognizer. When a gesture recognizer has received enough information from the event stream to interpret the
         * action, it calls its callback functions. Callback functions may be specified at construction or added to the
         * [gestureCallbacks]{@link GestureRecognizer#gestureCallbacks} list after construction.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., &lt;code>gestureCallback(recognizer)&lt;/code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
            // TODO: evaluate target usage
        var GestureRecognizer = function (target, callback) {
                if (!target) {
                    throw new ArgumentError(
                        Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "constructor", "missingTarget"));
                }

                /**
                 * Indicates the document element this gesture recognizer observes for UI events.
                 * @type {EventTarget}
                 * @readonly
                 */
                this.target = target;

                /**
                 * Indicates whether or not this gesture recognizer is enabled. When false, this gesture recognizer will
                 * ignore any events dispatched by its target.
                 * @type {Boolean}
                 * @default true
                 */
                this.enabled = true;

                // Documented with its property accessor below.
                this._state = WorldWind.POSSIBLE;

                // Intentionally not documented.
                this._nextState = null;

                // Documented with its property accessor below.
                this._clientX = 0;

                // Documented with its property accessor below.
                this._clientY = 0;

                // Intentionally not documented.
                this._clientStartX = 0;

                // Intentionally not documented.
                this._clientStartY = 0;

                // Documented with its property accessor below.
                this._translationX = 0;

                // Documented with its property accessor below.
                this._translationY = 0;

                // Intentionally not documented.
                this._translationWeight = 0.4;

                // Documented with its property accessor below.
                this._mouseButtonMask = 0;

                // Intentionally not documented.
                this._touches = [];

                // Intentionally not documented.
                this._touchCentroidShiftX = 0;

                // Intentionally not documented.
                this._touchCentroidShiftY = 0;

                // Documented with its property accessor below.
                this._gestureCallbacks = [];

                // Intentionally not documented.
                this._canRecognizeWith = [];

                // Intentionally not documented.
                this._requiresFailureOf = [];

                // Intentionally not documented.
                this._requiredToFailBy = [];

                // Add the optional gesture callback.
                if (callback) {
                    this._gestureCallbacks.push(callback);
                }

                // Intentionally not documented.
                this.listenerList = [];

                // Add this recognizer to the list of all recognizers.
                GestureRecognizer.allRecognizers.push(this);
            };

        // Intentionally not documented.
        GestureRecognizer.allRecognizers = [];

        Object.defineProperties(GestureRecognizer.prototype, {
            /**
             * Indicates this gesture's current state. Possible values are WorldWind.POSSIBLE, WorldWind.FAILED,
             * WorldWind.RECOGNIZED, WorldWind.BEGAN, WorldWind.CHANGED, WorldWind.CANCELLED and WorldWind.ENDED.
             * @type {String}
             * @default WorldWind.POSSIBLE
             * @memberof GestureRecognizer.prototype
             */
            state: {
                get: function () {
                    return this._state;
                },
                set: function (value) {
                    this.transitionToState(value);
                }
            },

            /**
             * Indicates the X coordinate of this gesture.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            clientX: {
                get: function () {
                    return this._clientX;
                },
                set: function (value) {
                    this._clientX = value;
                }
            },

            /**
             * Returns the Y coordinate of this gesture.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            clientY: {
                get: function () {
                    return this._clientY;
                },
                set: function (value) {
                    this._clientY = value;
                }
            },

            /**
             * Indicates this gesture's translation along the X axis since the gesture started.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            translationX: {
                get: function () {
                    return this._translationX;
                },
                set: function (value) {
                    this._translationX = value;
                    this._clientStartX = this._clientX;
                    this._touchCentroidShiftX = 0;
                }
            },

            /**
             * Indicates this gesture's translation along the Y axis since the gesture started.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            translationY: {
                get: function () {
                    return this._translationY;
                },
                set: function (value) {
                    this._translationY = value;
                    this._clientStartY = this._clientY;
                    this._touchCentroidShiftY = 0;
                }
            },

            /**
             * Indicates the currently pressed mouse buttons as a bitmask. A value of 0 indicates that no buttons are
             * pressed. A nonzero value indicates that one or more buttons are pressed as follows: bit 1 indicates the
             * primary button, bit 2 indicates the the auxiliary button, bit 3 indicates the secondary button.
             * @type {Number}
             * @readonly
             * @memberof GestureRecognizer.prototype
             */
            mouseButtonMask: {
                get: function () {
                    return this._mouseButtonMask;
                }
            },

            /**
             * Indicates the number of active touches.
             * @type {Number}
             * @readonly
             * @memberof GestureRecognizer.prototype
             */
            touchCount: {
                get: function () {
                    return this._touches.length;
                }
            },

            /**
             * The list of functions to call when this gesture is recognized. The functions have a single argument:
             * this gesture recognizer, e.g., &lt;code>gestureCallback(recognizer)&lt;/code>. Applications may
             * add functions to this array or remove them.
             * @type {Function[]}
             * @readonly
             * @memberof GestureRecognizer.prototype
             */
            gestureCallbacks: {
                get: function () {
                    return this._gestureCallbacks;
                }
            }
        });

        /**
         *
         * @param index
         * @returns {Touch}
         * @throws {ArgumentError} If the index is out of range.
         */
        GestureRecognizer.prototype.touch = function (index) {
            if (index &lt; 0 || index >= this._touches.length) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "touch", "indexOutOfRange"));
            }

            return this._touches[index];
        };

        /**
         *
         * @param recognizer
         */
        GestureRecognizer.prototype.recognizeSimultaneouslyWith = function (recognizer) {
            if (!recognizer) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "recognizeSimultaneouslyWith",
                        "The specified gesture recognizer is null or undefined."));
            }

            var index = this._canRecognizeWith.indexOf(recognizer);
            if (index == -1) {
                this._canRecognizeWith.push(recognizer);
                recognizer._canRecognizeWith.push(this);
            }
        };

        /**
         *
         * @param recognizer
         * @returns {Boolean}
         */
        GestureRecognizer.prototype.canRecognizeSimultaneouslyWith = function (recognizer) {
            var index = this._canRecognizeWith.indexOf(recognizer);
            return index != -1;
        };

        /**
         *
         * @param recognizer
         */
        GestureRecognizer.prototype.requireRecognizerToFail = function (recognizer) {
            if (!recognizer) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "requireRecognizerToFail",
                        "The specified gesture recognizer is null or undefined"));
            }

            var index = this._requiresFailureOf.indexOf(recognizer);
            if (index == -1) {
                this._requiresFailureOf.push(recognizer);
                recognizer._requiredToFailBy.push(this);
            }
        };

        /**
         *
         * @param recognizer
         * @returns {Boolean}
         */
        GestureRecognizer.prototype.requiresRecognizerToFail = function (recognizer) {
            var index = this._requiresFailureOf.indexOf(recognizer);
            return index != -1;
        };

        /**
         *
         * @param recognizer
         * @returns {Boolean}
         */
        GestureRecognizer.prototype.requiredToFailByRecognizer = function (recognizer) {
            var index = this._requiredToFailBy.indexOf(recognizer);
            return index != -1;
        };

        /**
         * @protected
         */
        GestureRecognizer.prototype.reset = function () {
            this._state = WorldWind.POSSIBLE;
            this._nextState = null;
            this._clientX = 0;
            this._clientY = 0;
            this._clientStartX = 0;
            this._clientStartY = 0;
            this._translationX = 0;
            this._translationY = 0;
            this._mouseButtonMask = 0;
            this._touches = [];
            this._touchCentroidShiftX = 0;
            this._touchCentroidShiftY = 0;
        };

        /**
         * @protected
         */
        GestureRecognizer.prototype.prepareToRecognize = function () {
        };

        /**
         *
         * @param event
         * @protected
         */
        GestureRecognizer.prototype.mouseDown = function (event) {
        };

        /**
         *
         * @param event
         * @protected
         */
        GestureRecognizer.prototype.mouseMove = function (event) {
        };

        /**
         *
         * @param event
         * @protected
         */
        GestureRecognizer.prototype.mouseUp = function (event) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchStart = function (touch) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchMove = function (touch) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchCancel = function (touch) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchEnd = function (touch) {
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.transitionToState = function (newState) {
            this._nextState = null; // clear any pending state transition

            if (newState === WorldWind.FAILED) {
                this._state = newState;
                this.updateRecognizersWaitingForFailure();
                this.resetIfEventsEnded();
            } else if (newState === WorldWind.RECOGNIZED) {
                this.tryToRecognize(newState); // may prevent the transition to Recognized
                if (this._state === newState) {
                    this.prepareToRecognize();
                    this.notifyListeners();
                    this.callGestureCallbacks();
                    this.resetIfEventsEnded();
                }
            } else if (newState === WorldWind.BEGAN) {
                this.tryToRecognize(newState); // may prevent the transition to Began
                if (this._state === newState) {
                    this.prepareToRecognize();
                    this.notifyListeners();
                    this.callGestureCallbacks();
                }
            } else if (newState === WorldWind.CHANGED) {
                this._state = newState;
                this.notifyListeners();
                this.callGestureCallbacks();
            } else if (newState === WorldWind.CANCELLED) {
                this._state = newState;
                this.notifyListeners();
                this.callGestureCallbacks();
                this.resetIfEventsEnded();
            } else if (newState === WorldWind.ENDED) {
                this._state = newState;
                this.notifyListeners();
                this.callGestureCallbacks();
                this.resetIfEventsEnded();
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.updateRecognizersWaitingForFailure = function () {
            // Transition gestures that are waiting for this gesture to transition to Failed.
            for (var i = 0, len = this._requiredToFailBy.length; i &lt; len; i++) {
                var recognizer = this._requiredToFailBy[i];
                if (recognizer._nextState != null) {
                    recognizer.transitionToState(recognizer._nextState);
                }
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.tryToRecognize = function (newState) {
            // Transition to Failed if another gesture can prevent this gesture from recognizing.
            if (GestureRecognizer.allRecognizers.some(this.canBePreventedByRecognizer, this)) {
                this.transitionToState(WorldWind.FAILED);
                return;
            }

            // Delay the transition to Recognized/Began if this gesture is waiting for a gesture in the Possible state.
            if (GestureRecognizer.allRecognizers.some(this.isWaitingForRecognizerToFail, this)) {
                this._nextState = newState;
                return;
            }

            // Transition to Failed all other gestures that can be prevented from recognizing by this gesture.
            var prevented = GestureRecognizer.allRecognizers.filter(this.canPreventRecognizer, this);
            for (var i = 0, len = prevented.length; i &lt; len; i++) {
                prevented[i].transitionToState(WorldWind.FAILED);
            }

            this._state = newState;
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.canPreventRecognizer = function (that) {
            return this != that &amp;&amp; this.target == that.target &amp;&amp; that.state == WorldWind.POSSIBLE &amp;&amp;
                (this.requiredToFailByRecognizer(that) || !this.canRecognizeSimultaneouslyWith(that));
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.canBePreventedByRecognizer = function (that) {
            return this != that &amp;&amp; this.target == that.target &amp;&amp; that.state == WorldWind.RECOGNIZED &amp;&amp;
                (this.requiresRecognizerToFail(that) || !this.canRecognizeSimultaneouslyWith(that));
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.isWaitingForRecognizerToFail = function (that) {
            return this != that &amp;&amp; this.target == that.target &amp;&amp; that.state == WorldWind.POSSIBLE &amp;&amp;
                this.requiresRecognizerToFail(that);
        };

        /**
         * Registers a gesture state listener on this GestureRecognizer. Registering state listeners using this function
         * enables applications to receive notifications of gesture recognition.
         *
         * Listeners must implement a gestureStateChanged method to receive notifications. The gestureStateChanged method will
         * receive one parameter containing a reference to the recognizer that changed state.
         *
         * @param listener The function to call when the event occurs.
         * @throws {ArgumentError} If any argument is null or undefined.
         */
        GestureRecognizer.prototype.addListener = function (listener) {
            if (!listener) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "addListener", "missingListener"));
            }
            this.listenerList.push(listener);
        };

        /**
         * Removes a gesture state listener from this GestureRecognizer. The listener must be the same object passed to
         * addListener. Calling removeListener with arguments that do not identify a currently registered
         * listener has no effect.
         *
         * @param listener The listener to remove. Must be the same object passed to addListener.
         * @throws {ArgumentError} If any argument is null or undefined.
         */
        GestureRecognizer.prototype.removeListener = function (listener) {
            if (!listener) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "removeListener", "missingListener"));
            }

            var index = this.listenerList.indexOf(listener);
            if (index !== -1) {
                this.listenerList.splice(index, 1); // remove the listener from the list
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.notifyListeners = function () {
            for (var i = 0; i &lt; this.listenerList.length; i++) {
                this.listenerList[i].gestureStateChanged(this);
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.callGestureCallbacks = function () {
            for (var i = 0, len = this._gestureCallbacks.length; i &lt; len; i++) {
                this._gestureCallbacks[i](this);
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.onGestureEvent = function (event) {
            if (!this.enabled) {
                return;
            }

            if (event.defaultPrevented &amp;&amp; this.state === WorldWind.POSSIBLE) {
                return; // ignore cancelled events while in the Possible state
            }

            var i, len;

            try {
                if (event.type === "mousedown") {
                    this.handleMouseDown(event);
                } else if (event.type === "mousemove") {
                    this.handleMouseMove(event);
                } else if (event.type === "mouseup") {
                    this.handleMouseUp(event);
                } else if (event.type === "touchstart") {
                    for (i = 0, len = event.changedTouches.length; i &lt; len; i++) {
                        this.handleTouchStart(event.changedTouches.item(i));
                    }
                } else if (event.type === "touchmove") {
                    for (i = 0, len = event.changedTouches.length; i &lt; len; i++) {
                        this.handleTouchMove(event.changedTouches.item(i));
                    }
                } else if (event.type === "touchcancel") {
                    for (i = 0, len = event.changedTouches.length; i &lt; len; i++) {
                        this.handleTouchCancel(event.changedTouches.item(i));
                    }
                } else if (event.type === "touchend") {
                    for (i = 0, len = event.changedTouches.length; i &lt; len; i++) {
                        this.handleTouchEnd(event.changedTouches.item(i));
                    }
                } else if (event.type === "pointerdown" &amp;&amp; event.pointerType === "mouse") {
                    this.handleMouseDown(event);
                } else if (event.type === "pointermove" &amp;&amp; event.pointerType === "mouse") {
                    this.handleMouseMove(event);
                } else if (event.type === "pointercancel" &amp;&amp; event.pointerType === "mouse") {
                    // Intentionally left blank. The W3C Pointer Events specification is ambiguous on what cancel means
                    // for mouse input, and there is no evidence that this event is actually generated (6/19/2015).
                } else if (event.type === "pointerup" &amp;&amp; event.pointerType === "mouse") {
                    this.handleMouseUp(event);
                } else if (event.type === "pointerdown" &amp;&amp; event.pointerType === "touch") {
                    this.handleTouchStart(event);
                } else if (event.type === "pointermove" &amp;&amp; event.pointerType === "touch") {
                    this.handleTouchMove(event);
                } else if (event.type === "pointercancel" &amp;&amp; event.pointerType === "touch") {
                    this.handleTouchCancel(event);
                } else if (event.type === "pointerup" &amp;&amp; event.pointerType === "touch") {
                    this.handleTouchEnd(event);
                } else {
                    Logger.logMessage(Logger.LEVEL_INFO, "GestureRecognizer", "handleEvent",
                        "Unrecognized event type: " + event.type);
                }
            } catch (e) {
                Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "handleEvent",
                    "Error handling event.\n" + e.toString());
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleMouseDown = function (event) {
            if (event.type == "mousedown" &amp;&amp; this._touches.length > 0) {
                return; // ignore synthesized mouse down events on Android Chrome
            }

            var buttonBit = (1 &lt;&lt; event.button);
            if (buttonBit &amp; this._mouseButtonMask != 0) {
                return; // ignore redundant mouse down events
            }

            if (this._mouseButtonMask == 0) { // first button down
                this._clientX = event.clientX;
                this._clientY = event.clientY;
                this._clientStartX = event.clientX;
                this._clientStartY = event.clientY;
                this._translationX = 0;
                this._translationY = 0;
            }

            this._mouseButtonMask |= buttonBit;
            this.mouseDown(event);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleMouseMove = function (event) {
            if (this._mouseButtonMask == 0) {
                return; // ignore mouse move events when this recognizer does not consider any button to be down
            }

            if (this._clientX == event.clientX &amp;&amp; this._clientY == event._clientY) {
                return; // ignore redundant mouse move events
            }

            var dx = event.clientX - this._clientStartX,
                dy = event.clientY - this._clientStartY,
                w = this._translationWeight;
            this._clientX = event.clientX;
            this._clientY = event.clientY;
            this._translationX = this._translationX * (1 - w) + dx * w;
            this._translationY = this._translationY * (1 - w) + dy * w;
            this.mouseMove(event);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleMouseUp = function (event) {
            var buttonBit = (1 &lt;&lt; event.button);
            if (buttonBit &amp; this._mouseButtonMask == 0) {
                return; // ignore mouse up events for buttons this recognizer does not consider to be down
            }

            this._mouseButtonMask &amp;= ~buttonBit;
            this.mouseUp(event);

            if (this._mouseButtonMask == 0) {
                this.resetIfEventsEnded(); // last button up
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchStart = function (event) {
            var touch = new Touch(event.identifier || event.pointerId, event.clientX, event.clientY); // touch events or pointer events
            this._touches.push(touch);

            if (this._touches.length == 1) { // first touch
                this._clientX = event.clientX;
                this._clientY = event.clientY;
                this._clientStartX = event.clientX;
                this._clientStartY = event.clientY;
                this._translationX = 0;
                this._translationY = 0;
                this._touchCentroidShiftX = 0;
                this._touchCentroidShiftY = 0;
            } else {
                this.touchesAddedOrRemoved();
            }

            this.touchStart(touch);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchMove = function (event) {
            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
            if (index == -1) {
                return; // ignore events for touches that did not start in this recognizer's target
            }

            var touch = this._touches[index];
            if (touch.clientX == event.clientX &amp;&amp; touch.clientY == event.clientY) {
                return; // ignore redundant touch move events, which we've encountered on Android Chrome
            }

            touch.clientX = event.clientX;
            touch.clientY = event.clientY;

            var centroid = this.touchCentroid(),
                dx = centroid.clientX - this._clientStartX + this._touchCentroidShiftX,
                dy = centroid.clientY - this._clientStartY + this._touchCentroidShiftY,
                w = this._translationWeight;
            this._clientX = centroid.clientX;
            this._clientY = centroid.clientY;
            this._translationX = this._translationX * (1 - w) + dx * w;
            this._translationY = this._translationY * (1 - w) + dy * w;

            this.touchMove(touch);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchCancel = function (event) {
            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
            if (index == -1) {
                return; // ignore events for touches that did not start in this recognizer's target
            }

            var touch = this._touches[index];
            this._touches.splice(index, 1);
            this.touchesAddedOrRemoved();
            this.touchCancel(touch);
            this.resetIfEventsEnded();
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchEnd = function (event) {
            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
            if (index == -1) {
                return; // ignore events for touches that did not start in this recognizer's target
            }

            var touch = this._touches[index];
            this._touches.splice(index, 1);
            this.touchesAddedOrRemoved();
            this.touchEnd(touch);
            this.resetIfEventsEnded();
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.resetIfEventsEnded = function () {
            if (this._state != WorldWind.POSSIBLE &amp;&amp; this._mouseButtonMask == 0 &amp;&amp; this._touches.length == 0) {
                this.reset();
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.touchesAddedOrRemoved = function () {
            this._touchCentroidShiftX += this._clientX;
            this._touchCentroidShiftY += this._clientY;
            var centroid = this.touchCentroid();
            this._clientX = centroid.clientX;
            this._clientY = centroid.clientY;
            this._touchCentroidShiftX -= this._clientX;
            this._touchCentroidShiftY -= this._clientY;
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.touchCentroid = function () {
            var x = 0,
                y = 0;

            for (var i = 0, len = this._touches.length; i &lt; len; i++) {
                var touch = this._touches[i];
                x += touch.clientX / len;
                y += touch.clientY / len;
            }

            return {clientX: x, clientY: y};
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.indexOfTouchWithId = function (identifier) {
            for (var i = 0, len = this._touches.length; i &lt; len; i++) {
                if (this._touches[i].identifier == identifier) {
                    return i;
                }
            }

            return -1;
        };

        return GestureRecognizer;
    });
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-AAIGridConstants.html">AAIGridConstants</a></li><li><a href="module-Angle.html">Angle</a></li><li><a href="module-ColladaUtils.html">ColladaUtils</a></li><li><a href="module-GeoJSONExporter.html">GeoJSONExporter</a></li><li><a href="module-HeatMapIntervalType.html">HeatMapIntervalType</a></li><li><a href="module-KmlElements.html">KmlElements</a></li><li><a href="module-KmlFileCache.html">KmlFileCache</a></li><li><a href="module-KmlNodeTransformers.html">KmlNodeTransformers</a></li><li><a href="module-KmlStyleResolver.html">KmlStyleResolver</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-MeasurerUtils.html">MeasurerUtils</a></li><li><a href="module-PolygonSplitter.html">PolygonSplitter</a></li><li><a href="module-SunPosition.html">SunPosition</a></li><li><a href="module-WktElements.html">WktElements</a></li><li><a href="module-WktExporter.html">WktExporter</a></li><li><a href="module-WorldWind.html">WorldWind</a></li><li><a href="module-WWMath.html">WWMath</a></li><li><a href="module-WWUtil.html">WWUtil</a></li></ul><h3>Classes</h3><ul><li><a href="AAIGridMetadata.html">AAIGridMetadata</a></li><li><a href="AAIGridReader.html">AAIGridReader</a></li><li><a href="AbsentResourceList.html">AbsentResourceList</a></li><li><a href="AbstractError.html">AbstractError</a></li><li><a href="AbstractMesh.html">AbstractMesh</a></li><li><a href="AbstractShape.html">AbstractShape</a></li><li><a href="Annotation.html">Annotation</a></li><li><a href="AnnotationAttributes.html">AnnotationAttributes</a></li><li><a href="AreaMeasurer.html">AreaMeasurer</a></li><li><a href="ArgumentError.html">ArgumentError</a></li><li><a href="AsterV2ElevationCoverage.html">AsterV2ElevationCoverage</a></li><li><a href="AtmosphereLayer.html">AtmosphereLayer</a></li><li><a href="AtmosphereProgram.html">AtmosphereProgram</a></li><li><a href="BasicProgram.html">BasicProgram</a></li><li><a href="BasicTextureProgram.html">BasicTextureProgram</a></li><li><a href="BasicTimeSequence.html">BasicTimeSequence</a></li><li><a href="BasicWorldWindowController.html">BasicWorldWindowController</a></li><li><a href="BingAerialLayer.html">BingAerialLayer</a></li><li><a href="BingAerialWithLabelsLayer.html">BingAerialWithLabelsLayer</a></li><li><a href="BingImageryUrlBuilder.html">BingImageryUrlBuilder</a></li><li><a href="BingRoadsLayer.html">BingRoadsLayer</a></li><li><a href="BingTiledImageLayer.html">BingTiledImageLayer</a></li><li><a href="BMNGLandsatLayer.html">BMNGLandsatLayer</a></li><li><a href="BMNGLayer.html">BMNGLayer</a></li><li><a href="BMNGOneImageLayer.html">BMNGOneImageLayer</a></li><li><a href="BMNGRestLayer.html">BMNGRestLayer</a></li><li><a href="BoundingBox.html">BoundingBox</a></li><li><a href="ByteBuffer.html">ByteBuffer</a></li><li><a href="ClickRecognizer.html">ClickRecognizer</a></li><li><a href="ColladaAsset.html">ColladaAsset</a></li><li><a href="ColladaImage.html">ColladaImage</a></li><li><a href="ColladaLoader.html">ColladaLoader</a></li><li><a href="ColladaMaterial.html">ColladaMaterial</a></li><li><a href="ColladaMesh.html">ColladaMesh</a></li><li><a href="ColladaNode.html">ColladaNode</a></li><li><a href="ColladaScene.html">ColladaScene</a></li><li><a href="Color.html">Color</a></li><li><a href="Compass.html">Compass</a></li><li><a href="CompassLayer.html">CompassLayer</a></li><li><a href="CoordinatesDisplayLayer.html">CoordinatesDisplayLayer</a></li><li><a href="DateWW.html">DateWW</a></li><li><a href="DBaseFile.html">DBaseFile</a></li><li><a href="DigitalGlobeTiledImageLayer.html">DigitalGlobeTiledImageLayer</a></li><li><a href="DragRecognizer.html">DragRecognizer</a></li><li><a href="DrawContext.html">DrawContext</a></li><li><a href="EarthElevationModel.html">EarthElevationModel</a></li><li><a href="EarthRestElevationCoverage.html">EarthRestElevationCoverage</a></li><li><a href="ElevationCoverage.html">ElevationCoverage</a></li><li><a href="ElevationImage.html">ElevationImage</a></li><li><a href="ElevationModel.html">ElevationModel</a></li><li><a href="Font.html">Font</a></li><li><a href="FramebufferTexture.html">FramebufferTexture</a></li><li><a href="FramebufferTile.html">FramebufferTile</a></li><li><a href="FramebufferTileController.html">FramebufferTileController</a></li><li><a href="FrameStatistics.html">FrameStatistics</a></li><li><a href="FrameStatisticsLayer.html">FrameStatisticsLayer</a></li><li><a href="Frustum.html">Frustum</a></li><li><a href="GebcoElevationCoverage.html">GebcoElevationCoverage</a></li><li><a href="GeographicMesh.html">GeographicMesh</a></li><li><a href="GeographicProjection.html">GeographicProjection</a></li><li><a href="GeographicText.html">GeographicText</a></li><li><a href="GeoJSONConstants.html">GeoJSONConstants</a></li><li><a href="GeoJSONCRS.html">GeoJSONCRS</a></li><li><a href="GeoJSONFeature.html">GeoJSONFeature</a></li><li><a href="GeoJSONFeatureCollection.html">GeoJSONFeatureCollection</a></li><li><a href="GeoJSONGeometry.html">GeoJSONGeometry</a></li><li><a href="GeoJSONGeometryCollection.html">GeoJSONGeometryCollection</a></li><li><a href="GeoJSONGeometryLineString.html">GeoJSONGeometryLineString</a></li><li><a href="GeoJSONGeometryMultiLineString.html">GeoJSONGeometryMultiLineString</a></li><li><a href="GeoJSONGeometryMultiPoint.html">GeoJSONGeometryMultiPoint</a></li><li><a href="GeoJSONGeometryMultiPolygon.html">GeoJSONGeometryMultiPolygon</a></li><li><a href="GeoJSONGeometryPoint.html">GeoJSONGeometryPoint</a></li><li><a href="GeoJSONGeometryPolygon.html">GeoJSONGeometryPolygon</a></li><li><a href="GeoJSONParser.html">GeoJSONParser</a></li><li><a href="GeoTiff.html">GeoTiff</a></li><li><a href="GeoTiffKeyEntry.html">GeoTiffKeyEntry</a></li><li><a href="GeoTiffMetadata.html">GeoTiffMetadata</a></li><li><a href="GeoTiffReader.html">GeoTiffReader</a></li><li><a href="GestureRecognizer.html">GestureRecognizer</a></li><li><a href="Globe.html">Globe</a></li><li><a href="Globe2D.html">Globe2D</a></li><li><a href="GoToAnimator.html">GoToAnimator</a></li><li><a href="GpuProgram.html">GpuProgram</a></li><li><a href="GpuResourceCache.html">GpuResourceCache</a></li><li><a href="GpuShader.html">GpuShader</a></li><li><a href="GroundProgram.html">GroundProgram</a></li><li><a href="HashMap.html">HashMap</a></li><li><a href="HeatMapColoredTile.html">HeatMapColoredTile</a></li><li><a href="HeatMapLayer.html">HeatMapLayer</a></li><li><a href="HeatMapTile.html">HeatMapTile</a></li><li><a href="HighlightController.html">HighlightController</a></li><li><a href="ImageSource.html">ImageSource</a></li><li><a href="ImageTile.html">ImageTile</a></li><li><a href="Insets.html">Insets</a></li><li><a href="KmlAbstractView.html">KmlAbstractView</a></li><li><a href="KmlAttribute.html">KmlAttribute</a></li><li><a href="KmlBalloonStyle.html">KmlBalloonStyle</a></li><li><a href="KmlCamera.html">KmlCamera</a></li><li><a href="KmlChange.html">KmlChange</a></li><li><a href="KmlColorStyle.html">KmlColorStyle</a></li><li><a href="KmlContainer.html">KmlContainer</a></li><li><a href="KmlControls.html">KmlControls</a></li><li><a href="KmlCreate.html">KmlCreate</a></li><li><a href="KmlDelete.html">KmlDelete</a></li><li><a href="KmlDocument.html">KmlDocument</a></li><li><a href="KmlElementsFactory.html">KmlElementsFactory</a></li><li><a href="KmlElementsFactoryCached.html">KmlElementsFactoryCached</a></li><li><a href="KmlFeature.html">KmlFeature</a></li><li><a href="KmlFile.html">KmlFile</a></li><li><a href="KmlFolder.html">KmlFolder</a></li><li><a href="KmlGeometry.html">KmlGeometry</a></li><li><a href="KmlGroundOverlay.html">KmlGroundOverlay</a></li><li><a href="KmlHrefResolver.html">KmlHrefResolver</a></li><li><a href="KmlIcon.html">KmlIcon</a></li><li><a href="KmlIconStyle.html">KmlIconStyle</a></li><li><a href="KmlImagePyramid.html">KmlImagePyramid</a></li><li><a href="KmlItemIcon.html">KmlItemIcon</a></li><li><a href="KmlLabelStyle.html">KmlLabelStyle</a></li><li><a href="KmlLatLonAltBox.html">KmlLatLonAltBox</a></li><li><a href="KmlLatLonBox.html">KmlLatLonBox</a></li><li><a href="KmlLatLonQuad.html">KmlLatLonQuad</a></li><li><a href="KmlLinearRing.html">KmlLinearRing</a></li><li><a href="KmlLineString.html">KmlLineString</a></li><li><a href="KmlLineStyle.html">KmlLineStyle</a></li><li><a href="KmlLink.html">KmlLink</a></li><li><a href="KmlListStyle.html">KmlListStyle</a></li><li><a href="KmlLocation.html">KmlLocation</a></li><li><a href="KmlLod.html">KmlLod</a></li><li><a href="KmlLookAt.html">KmlLookAt</a></li><li><a href="KmlMultiGeometry.html">KmlMultiGeometry</a></li><li><a href="KmlMultiTrack.html">KmlMultiTrack</a></li><li><a href="KmlNetworkLink.html">KmlNetworkLink</a></li><li><a href="KmlNetworkLinkControl.html">KmlNetworkLinkControl</a></li><li><a href="KmlObject.html">KmlObject</a></li><li><a href="KmlOrientation.html">KmlOrientation</a></li><li><a href="KmlOverlay.html">KmlOverlay</a></li><li><a href="KmlPair.html">KmlPair</a></li><li><a href="KmlPhotoOverlay.html">KmlPhotoOverlay</a></li><li><a href="KmlPlacemark.html">KmlPlacemark</a></li><li><a href="KmlPoint.html">KmlPoint</a></li><li><a href="KmlPolygon.html">KmlPolygon</a></li><li><a href="KmlPolyStyle.html">KmlPolyStyle</a></li><li><a href="KmlRefreshListener.html">KmlRefreshListener</a></li><li><a href="KmlRefreshListener.Event.html">Event</a></li><li><a href="KmlRegion.html">KmlRegion</a></li><li><a href="KmlRemoteFile.html">KmlRemoteFile</a></li><li><a href="KmlScale.html">KmlScale</a></li><li><a href="KmlSchema.html">KmlSchema</a></li><li><a href="KmlScreenOverlay.html">KmlScreenOverlay</a></li><li><a href="KmlStyle.html">KmlStyle</a></li><li><a href="KmlStyleMap.html">KmlStyleMap</a></li><li><a href="KmlStyleSelector.html">KmlStyleSelector</a></li><li><a href="KmlSubStyle.html">KmlSubStyle</a></li><li><a href="KmlTimePrimitive.html">KmlTimePrimitive</a></li><li><a href="KmlTimeSpan.html">KmlTimeSpan</a></li><li><a href="KmlTimeStamp.html">KmlTimeStamp</a></li><li><a href="KmlTour.html">KmlTour</a></li><li><a href="KmlTrack.html">KmlTrack</a></li><li><a href="KmlTreeKeyValueCache.html">KmlTreeKeyValueCache</a></li><li><a href="KmlTreeVisibility.html">KmlTreeVisibility</a></li><li><a href="KmlViewVolume.html">KmlViewVolume</a></li><li><a href="KmzFile.html">KmzFile</a></li><li><a href="LandsatRestLayer.html">LandsatRestLayer</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LengthMeasurer.html">LengthMeasurer</a></li><li><a href="Level.html">Level</a></li><li><a href="LevelRowColumnUrlBuilder.html">LevelRowColumnUrlBuilder</a></li><li><a href="libtess.ActiveRegion.html">ActiveRegion</a></li><li><a href="libtess.CachedVertex.html">CachedVertex</a></li><li><a href="libtess.Dict.html">Dict</a></li><li><a href="libtess.DictNode.html">DictNode</a></li><li><a href="libtess.GluFace.html">GluFace</a></li><li><a href="libtess.GluHalfEdge.html">GluHalfEdge</a></li><li><a href="libtess.GluMesh.html">GluMesh</a></li><li><a href="libtess.GluTesselator.html">GluTesselator</a></li><li><a href="libtess.GluVertex.html">GluVertex</a></li><li><a href="libtess.PQHandleElem.html">PQHandleElem</a></li><li><a href="libtess.PQNode.html">PQNode</a></li><li><a href="libtess.PriorityQ.html">PriorityQ</a></li><li><a href="libtess.PriorityQHeap.html">PriorityQHeap</a></li><li><a href="Line.html">Line</a></li><li><a href="Location.html">Location</a></li><li><a href="LookAtNavigator.html">LookAtNavigator</a></li><li><a href="Matrix.html">Matrix</a></li><li><a href="Matrix3.html">Matrix3</a></li><li><a href="MeasuredLocation.html">MeasuredLocation</a></li><li><a href="MemoryCache.html">MemoryCache</a></li><li><a href="MemoryCacheListener.html">MemoryCacheListener</a></li><li><a href="MercatorTiledImageLayer.html">MercatorTiledImageLayer</a></li><li><a href="Navigator.html">Navigator</a></li><li><a href="NominatimGeocoder.html">NominatimGeocoder</a></li><li><a href="NotYetImplementedError.html">NotYetImplementedError</a></li><li><a href="Offset.html">Offset</a></li><li><a href="OpenStreetMapImageLayer.html">OpenStreetMapImageLayer</a></li><li><a href="OrderedRenderable.html">OrderedRenderable</a></li><li><a href="OwsConstraint.html">OwsConstraint</a></li><li><a href="OwsDescription.html">OwsDescription</a></li><li><a href="OwsLanguageString.html">OwsLanguageString</a></li><li><a href="OwsOperationsMetadata.html">OwsOperationsMetadata</a></li><li><a href="OwsServiceIdentification.html">OwsServiceIdentification</a></li><li><a href="OwsServiceProvider.html">OwsServiceProvider</a></li><li><a href="PanRecognizer.html">PanRecognizer</a></li><li><a href="Path.html">Path</a></li><li><a href="PeriodicTimeSequence.html">PeriodicTimeSequence</a></li><li><a href="PickedObject.html">PickedObject</a></li><li><a href="PickedObjectList.html">PickedObjectList</a></li><li><a href="PinchRecognizer.html">PinchRecognizer</a></li><li><a href="Placemark.html">Placemark</a></li><li><a href="PlacemarkAttributes.html">PlacemarkAttributes</a></li><li><a href="Plane.html">Plane</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="Position.html">Position</a></li><li><a href="PrjFile.html">PrjFile</a></li><li><a href="ProjectionEquirectangular.html">ProjectionEquirectangular</a></li><li><a href="ProjectionGnomonic.html">ProjectionGnomonic</a></li><li><a href="ProjectionMercator.html">ProjectionMercator</a></li><li><a href="ProjectionPolarEquidistant.html">ProjectionPolarEquidistant</a></li><li><a href="ProjectionUPS.html">ProjectionUPS</a></li><li><a href="ProjectionWgs84.html">ProjectionWgs84</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="Renderable.html">Renderable</a></li><li><a href="RenderableLayer.html">RenderableLayer</a></li><li><a href="RestTiledImageLayer.html">RestTiledImageLayer</a></li><li><a href="RotationRecognizer.html">RotationRecognizer</a></li><li><a href="ScreenCreditController.html">ScreenCreditController</a></li><li><a href="ScreenImage.html">ScreenImage</a></li><li><a href="ScreenText.html">ScreenText</a></li><li><a href="Sector.html">Sector</a></li><li><a href="ShapeAttributes.html">ShapeAttributes</a></li><li><a href="Shapefile.html">Shapefile</a></li><li><a href="ShapefileRecord.html">ShapefileRecord</a></li><li><a href="ShapefileRecordMultiPoint.html">ShapefileRecordMultiPoint</a></li><li><a href="ShapefileRecordNull.html">ShapefileRecordNull</a></li><li><a href="ShapefileRecordPoint.html">ShapefileRecordPoint</a></li><li><a href="ShapefileRecordPolygon.html">ShapefileRecordPolygon</a></li><li><a href="ShapefileRecordPolyline.html">ShapefileRecordPolyline</a></li><li><a href="SkyProgram.html">SkyProgram</a></li><li><a href="StarFieldLayer.html">StarFieldLayer</a></li><li><a href="StarFieldProgram.html">StarFieldProgram</a></li><li><a href="SurfaceCircle.html">SurfaceCircle</a></li><li><a href="SurfaceEllipse.html">SurfaceEllipse</a></li><li><a href="SurfaceImage.html">SurfaceImage</a></li><li><a href="SurfacePolygon.html">SurfacePolygon</a></li><li><a href="SurfacePolyline.html">SurfacePolyline</a></li><li><a href="SurfaceRectangle.html">SurfaceRectangle</a></li><li><a href="SurfaceRenderable.html">SurfaceRenderable</a></li><li><a href="SurfaceSector.html">SurfaceSector</a></li><li><a href="SurfaceShape.html">SurfaceShape</a></li><li><a href="SurfaceShapeTile.html">SurfaceShapeTile</a></li><li><a href="SurfaceTile.html">SurfaceTile</a></li><li><a href="SurfaceTileRenderer.html">SurfaceTileRenderer</a></li><li><a href="SurfaceTileRendererProgram.html">SurfaceTileRendererProgram</a></li><li><a href="TapRecognizer.html">TapRecognizer</a></li><li><a href="TectonicPlatesLayer.html">TectonicPlatesLayer</a></li><li><a href="Terrain.html">Terrain</a></li><li><a href="TerrainTile.html">TerrainTile</a></li><li><a href="TerrainTileList.html">TerrainTileList</a></li><li><a href="Tessellator.html">Tessellator</a></li><li><a href="Text.html">Text</a></li><li><a href="TextAttributes.html">TextAttributes</a></li><li><a href="TextRenderer.html">TextRenderer</a></li><li><a href="Texture.html">Texture</a></li><li><a href="TextureTile.html">TextureTile</a></li><li><a href="TiffConstants.html">TiffConstants</a></li><li><a href="TiffIFDEntry.html">TiffIFDEntry</a></li><li><a href="Tile.html">Tile</a></li><li><a href="TiledElevationCoverage.html">TiledElevationCoverage</a></li><li><a href="TiledImageLayer.html">TiledImageLayer</a></li><li><a href="TileFactory.html">TileFactory</a></li><li><a href="TiltRecognizer.html">TiltRecognizer</a></li><li><a href="Touch.html">Touch</a></li><li><a href="TriangleMesh.html">TriangleMesh</a></li><li><a href="UnsupportedOperationError.html">UnsupportedOperationError</a></li><li><a href="UrlBuilder.html">UrlBuilder</a></li><li><a href="UsgsNedElevationCoverage.html">UsgsNedElevationCoverage</a></li><li><a href="UsgsNedHiElevationCoverage.html">UsgsNedHiElevationCoverage</a></li><li><a href="Vec2.html">Vec2</a></li><li><a href="Vec3.html">Vec3</a></li><li><a href="ViewControlsLayer.html">ViewControlsLayer</a></li><li><a href="WcsCapabilities.html">WcsCapabilities</a></li><li><a href="WcsCoverageDescriptions.html">WcsCoverageDescriptions</a></li><li><a href="WcsEarthElevationCoverage.html">WcsEarthElevationCoverage</a></li><li><a href="WcsTileUrlBuilder.html">WcsTileUrlBuilder</a></li><li><a href="WFSCapabilities.html">WFSCapabilities</a></li><li><a href="Wkt.html">Wkt</a></li><li><a href="WktGeometryCollection.html">WktGeometryCollection</a></li><li><a href="WktLineString.html">WktLineString</a></li><li><a href="WktMultiLineString.html">WktMultiLineString</a></li><li><a href="WktMultiPoint.html">WktMultiPoint</a></li><li><a href="WktMultiPolygon.html">WktMultiPolygon</a></li><li><a href="WktObject.html">WktObject</a></li><li><a href="WktPoint.html">WktPoint</a></li><li><a href="WktPolygon.html">WktPolygon</a></li><li><a href="WktTriangle.html">WktTriangle</a></li><li><a href="WktType.html">WktType</a></li><li><a href="WMSCapabilities.html">WMSCapabilities</a></li><li><a href="WmsLayer.html">WmsLayer</a></li><li><a href="WmsLayerCapabilities.html">WmsLayerCapabilities</a></li><li><a href="WmsTimeDimensionedLayer.html">WmsTimeDimensionedLayer</a></li><li><a href="WmsUrlBuilder.html">WmsUrlBuilder</a></li><li><a href="WmtsCapabilities.html">WmtsCapabilities</a></li><li><a href="WmtsLayer.html">WmtsLayer</a></li><li><a href="WmtsLayerCapabilities.html">WmtsLayerCapabilities</a></li><li><a href="WorldWindow.html">WorldWindow</a></li><li><a href="WorldWindowController.html">WorldWindowController</a></li></ul><h3>Global</h3><ul><li><a href="global.html#catch">catch</a></li><li><a href="global.html#crs">crs</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#maxElevation">maxElevation</a></li><li><a href="global.html#minElevation">minElevation</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#then">then</a></li><li><a href="global.html#timestamp">timestamp</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Tue Apr 06 2021 10:24:41 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
