<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WorldWind: Source: util/WWMath.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: util/WWMath.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2003-2006, 2009, 2017, 2020 United States Government, as represented
 * by the Administrator of the National Aeronautics and Space Administration.
 * All rights reserved.
 *
 * The NASAWorldWind/WebWorldWind platform is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License
 * at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * NASAWorldWind/WebWorldWind also contains the following 3rd party Open Source
 * software:
 *
 *    ES6-Promise – under MIT License
 *    libtess.js – SGI Free Software License B
 *    Proj4 – under MIT License
 *    JSZip – under MIT License
 *
 * A complete listing of 3rd Party software notices and licenses included in
 * WebWorldWind can be found in the WebWorldWind 3rd-party notices and licenses
 * PDF found in code  directory.
 */
define([
        '../geom/Angle',
        '../error/ArgumentError',
        '../geom/Line',
        '../util/Logger',
        '../geom/Rectangle',
        '../geom/Vec3'
    ],
    function (Angle,
              ArgumentError,
              Line,
              Logger,
              Rectangle,
              Vec3) {
        "use strict";
        /**
         * Provides math constants and functions.
         * @exports WWMath
         */
        var WWMath = {

            /**
             * Returns a number within the range of a specified minimum and maximum.
             * @param {Number} value The value to clamp.
             * @param {Number} minimum The minimum value to return.
             * @param {Number} maximum The maximum value to return.
             * @returns {Number} The minimum value if the specified value is less than the minimum, the maximum value if
             * the specified value is greater than the maximum, otherwise the value specified is returned.
             */
            clamp: function (value, minimum, maximum) {
                return value &lt; minimum ? minimum : value > maximum ? maximum : value;
            },

            /**
             * Computes a number between two numbers.
             * @param amount {Number} The relative distance between the numbers at which to compute the new number. This
             * should normally be a number between 0 and 1 but whatever number is specified is applied.
             * @param {Number} value1 The first number.
             * @param {Number} value2 The second number.
             * @returns {Number} the computed value.
             */
            interpolate: function (amount, value1, value2) {
                return (1 - amount) * value1 + amount * value2;
            },

            /**
             * Returns the cube root of a specified value.
             * @param {Number} x The value whose cube root is computed.
             * @returns {Number} The cube root of the specified number.
             */
            cbrt: function (x) {
                // Use the built-in version if it exists. cbrt() is defined in ECMA6.
                if (typeof Math.cbrt == 'function') {
                    return Math.cbrt(x);
                } else {
                    return Math.pow(x, 1 / 3);
                }
            },

            /**
             * Computes the Cartesian intersection point of a specified line with an ellipsoid.
             * @param {Line} line The line for which to compute the intersection.
             * @param {Number} equatorialRadius The ellipsoid's major radius.
             * @param {Number} polarRadius The ellipsoid's minor radius.
             * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
             * @returns {boolean} true if the line intersects the ellipsoid, otherwise false
             * @throws {ArgumentError} If the specified line or result is null or undefined.
             * @deprecated utilize the Globe.intersectsLine method attached implementation
             */
            computeEllipsoidalGlobeIntersection: function (line, equatorialRadius, polarRadius, result) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeEllipsoidalGlobeIntersection", "missingLine"));
                }

                if (!result) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeEllipsoidalGlobeIntersection", "missingResult"));
                }

                // Taken from "Mathematics for 3D Game Programming and Computer Graphics, Second Edition", Section 5.2.3.
                //
                // Note that the parameter n from in equations 5.70 and 5.71 is omitted here. For an ellipsoidal globe this
                // parameter is always 1, so its square and its product with any other value simplifies to the identity.

                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    m = equatorialRadius / polarRadius, // ratio of the x semi-axis length to the y semi-axis length
                    m2 = m * m,
                    r2 = equatorialRadius * equatorialRadius, // nominal radius squared
                    a = vx * vx + m2 * vy * vy + vz * vz,
                    b = 2 * (sx * vx + m2 * sy * vy + sz * vz),
                    c = sx * sx + m2 * sy * sy + sz * sz - r2,
                    d = b * b - 4 * a * c, // discriminant
                    t;

                if (d &lt; 0) {
                    return false;
                } else {
                    t = (-b - Math.sqrt(d)) / (2 * a);
                    result[0] = sx + vx * t;
                    result[1] = sy + vy * t;
                    result[2] = sz + vz * t;
                    return true;
                }
            },

            /**
             * Returns the normal vector corresponding to the triangle defined by three vertices (a, b, c).
             *
             * @param {Vec3} a The triangle's first vertex.
             * @param {Vec3} b The triangle's second vertex.
             * @param {Vec3} c The triangle's third vertex.
             *
             * @return {Vec3} the triangle's unit-length normal vector.
             *
             * @throws {ArgumentError} If the specified vertices are null or undefined.
             */
            computeTriangleNormal: function (a, b, c) {
                if (!a || !b || !c) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleNormal", "missingVertex"));
                }

                var x = ((b[1] - a[1]) * (c[2] - a[2])) - ((b[2] - a[2]) * (c[1] - a[1]));
                var y = ((b[2] - a[2]) * (c[0] - a[0])) - ((b[0] - a[0]) * (c[2] - a[2]));
                var z = ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0]));

                var length = (x * x) + (y * y) + (z * z);
                if (length == 0) {
                    return new Vec3(x, y, z);
                }

                length = Math.sqrt(length);
                return new Vec3(x / length, y / length, z / length);
            },

            /**
             * Computes the Cartesian intersection point of a specified line with a triangle.
             * @param {Line} line The line for which to compute the intersection.
             * @param {Vec3} vertex0 The triangle's first vertex.
             * @param {Vec3} vertex1 The triangle's second vertex.
             * @param {Vec3} vertex2 The triangle's third vertex.
             * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
             * @returns {boolean} true if the line intersects the triangle, otherwise false
             * @throws {ArgumentError} If the specified line, vertex or result is null or undefined.
             */
            computeTriangleIntersection: function (line, vertex0, vertex1, vertex2, result) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleIntersection", "missingLine"));
                }

                if (!vertex0 || !vertex1 || !vertex2) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleIntersection", "missingVertex"));
                }

                if (!result) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleIntersection", "missingResult"));
                }

                // Taken from Moller and Trumbore
                // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    EPSILON = 0.00001;

                // find vectors for two edges sharing point a: vertex1 - vertex0 and vertex2 - vertex0
                var edge1x = vertex1[0] - vertex0[0],
                    edge1y = vertex1[1] - vertex0[1],
                    edge1z = vertex1[2] - vertex0[2],
                    edge2x = vertex2[0] - vertex0[0],
                    edge2y = vertex2[1] - vertex0[1],
                    edge2z = vertex2[2] - vertex0[2];

                // Compute cross product of line direction and edge2
                var px = (vy * edge2z) - (vz * edge2y),
                    py = (vz * edge2x) - (vx * edge2z),
                    pz = (vx * edge2y) - (vy * edge2x);

                // Get determinant
                var det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p
                if (det > -EPSILON &amp;&amp; det &lt; EPSILON) { // if det is near zero then ray lies in plane of triangle
                    return false;
                }

                var inv_det = 1.0 / det;

                // Compute distance for vertex A to ray origin: origin - vertex0
                var tx = sx - vertex0[0],
                    ty = sy - vertex0[1],
                    tz = sz - vertex0[2];

                // Calculate u parameter and test bounds: 1/det * t dot p
                var u = inv_det * (tx * px + ty * py + tz * pz);
                if (u &lt; -EPSILON || u > 1 + EPSILON) {
                    return false;
                }

                // Prepare to test v parameter: t cross edge1
                var qx = (ty * edge1z) - (tz * edge1y),
                    qy = (tz * edge1x) - (tx * edge1z),
                    qz = (tx * edge1y) - (ty * edge1x);

                // Calculate v parameter and test bounds: 1/det * dir dot q
                var v = inv_det * (vx * qx + vy * qy + vz * qz);
                if (v &lt; -EPSILON || u + v > 1 + EPSILON) {
                    return false;
                }

                // Calculate the point of intersection on the line: t = 1/det * edge2 dot q
                var t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);
                if (t &lt; 0) {
                    return false;
                } else {
                    result[0] = sx + vx * t;
                    result[1] = sy + vy * t;
                    result[2] = sz + vz * t;
                    return true;
                }
            },

            computeIndexedTrianglesIntersection: function (line, points, indices, results) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingLine"));
                }

                if (!points) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingPoints"));
                }

                if (!indices) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingIndices"));
                }

                if (!results) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingResults"));
                }

                var v0 = new Vec3(0, 0, 0),
                    v1 = new Vec3(0, 0, 0),
                    v2 = new Vec3(0, 0, 0),
                    iPoint = new Vec3(0, 0, 0);

                for (var i = 0, len = indices.length; i &lt; len; i += 3) {
                    var i0 = 3 * indices[i],
                        i1 = 3 * indices[i + 1],
                        i2 = 3 * indices[i + 2];

                    v0[0] = points[i0];
                    v0[1] = points[i0 + 1];
                    v0[2] = points[i0 + 2];

                    v1[0] = points[i1];
                    v1[1] = points[i1 + 1];
                    v1[2] = points[i1 + 2];

                    v2[0] = points[i2];
                    v2[1] = points[i2 + 1];
                    v2[2] = points[i2 + 2];

                    if (WWMath.computeTriangleIntersection(line, v0, v1, v2, iPoint)) {
                        results.push(iPoint);
                        iPoint = new Vec3(0, 0, 0);
                    }
                }

                return results.length > 0;
            },

            /**
             * Computes the Cartesian intersection points of a specified line with a triangle strip. The triangle strip
             * is specified by a list of vertex points and a list of indices indicating the triangle strip tessellation
             * of those vertices. The triangle strip indices are interpreted in the same manner as WebGL, where each
             * index indicates a vertex position rather than an actual index into the points array (e.g. a triangle
             * strip index of 1 indicates the XYZ tuple starting at array index 3). This is equivalent to calling
             * computeTriangleIntersection for each individual triangle in the triangle strip, but is potentially much
             * more efficient.
             * @param {Line} line The line for which to compute the intersection.
             * @param {Array} points The list of vertex points, organized as a list of tightly-packed XYZ tuples.
             * @param {Array} indices The list of triangle strip indices, organized as a list of vertex positions.
             * @param {Array} results A pre-allocated array instance in which to return the intersection points as
             * {@link Vec3} instances.
             * @throws {ArgumentError} If the specified line, points, indices or results is null or undefined.
             */
            computeTriStripIntersections: function (line, points, indices, results) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingLine"));
                }

                if (!points) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingPoints"));
                }

                if (!indices) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingIndices"));
                }

                if (!results) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingResults"));
                }

                // Taken from Moller and Trumbore
                // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

                // Adapted from the original ray-triangle intersection algorithm to optimize for ray-triangle strip
                // intersection. We optimize by reusing constant terms, replacing use of Vec3 with inline primitives,
                // and exploiting the triangle strip organization to reuse computations common to adjacent triangles.
                // These optimizations reduce worst-case terrain picking performance by approximately 50% in Chrome on a
                // 2010 iMac and a Nexus 9.

                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    vert0x, vert0y, vert0z,
                    vert1x, vert1y, vert1z,
                    vert2x, vert2y, vert2z,
                    edge1x, edge1y, edge1z,
                    edge2x, edge2y, edge2z,
                    px, py, pz,
                    tx, ty, tz,
                    qx, qy, qz,
                    u, v, t,
                    det, inv_det,
                    index,
                    EPSILON = 0.00001;

                // Get the triangle strip's first vertex.
                index = 3 * indices[0];
                vert1x = points[index++];
                vert1y = points[index++];
                vert1z = points[index];

                // Get the triangle strip's second vertex.
                index = 3 * indices[1];
                vert2x = points[index++];
                vert2y = points[index++];
                vert2z = points[index];

                // Compute the intersection of each triangle with the specified ray.
                for (var i = 2, len = indices.length; i &lt; len; i++) {
                    // Move the last two vertices into the first two vertices. This takes advantage of the triangle
                    // strip's structure and avoids redundant reads from points and indices. During the first
                    // iteration this places the triangle strip's first three vertices in vert0, vert1 and vert2,
                    // respectively.
                    vert0x = vert1x;
                    vert0y = vert1y;
                    vert0z = vert1z;
                    vert1x = vert2x;
                    vert1y = vert2y;
                    vert1z = vert2z;

                    // Get the triangle strip's next vertex.
                    index = 3 * indices[i];
                    vert2x = points[index++];
                    vert2y = points[index++];
                    vert2z = points[index];

                    // find vectors for two edges sharing point a: vert1 - vert0 and vert2 - vert0
                    edge1x = vert1x - vert0x;
                    edge1y = vert1y - vert0y;
                    edge1z = vert1z - vert0z;
                    edge2x = vert2x - vert0x;
                    edge2y = vert2y - vert0y;
                    edge2z = vert2z - vert0z;

                    // Compute cross product of line direction and edge2
                    px = (vy * edge2z) - (vz * edge2y);
                    py = (vz * edge2x) - (vx * edge2z);
                    pz = (vx * edge2y) - (vy * edge2x);

                    // Get determinant
                    det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p
                    if (det > -EPSILON &amp;&amp; det &lt; EPSILON) { // if det is near zero then ray lies in plane of triangle
                        continue;
                    }

                    inv_det = 1.0 / det;

                    // Compute distance for vertex A to ray origin: origin - vert0
                    tx = sx - vert0x;
                    ty = sy - vert0y;
                    tz = sz - vert0z;

                    // Calculate u parameter and test bounds: 1/det * t dot p
                    u = inv_det * (tx * px + ty * py + tz * pz);
                    if (u &lt; -EPSILON || u > 1 + EPSILON) {
                        continue;
                    }

                    // Prepare to test v parameter: tvec cross edge1
                    qx = (ty * edge1z) - (tz * edge1y);
                    qy = (tz * edge1x) - (tx * edge1z);
                    qz = (tx * edge1y) - (ty * edge1x);

                    // Calculate v parameter and test bounds: 1/det * dir dot q
                    v = inv_det * (vx * qx + vy * qy + vz * qz);
                    if (v &lt; -EPSILON || u + v > 1 + EPSILON) {
                        continue;
                    }

                    // Calculate the point of intersection on the line: t = 1/det * edge2 dot q
                    t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);
                    if (t >= 0) {
                        results.push(new Vec3(sx + vx * t, sy + vy * t, sz + vz * t));
                    }
                }
            },

            /**
             * Computes the absolute value of a specified value.
             * @param {Number} a The value whose absolute value to compute.
             * @returns {Number} The absolute value of the specified number.
             */
            fabs: function (a) {
                return a >= 0 ? a : -a;
            },

            /**
             * Computes the floating-point modulus of a specified number.
             * @param {Number} number The number whose modulus to compute.
             * @param {Number} modulus The modulus.
             * @returns {Number} The remainder after dividing the number by the modulus: number % modulus.
             */
            fmod: function (number, modulus) {
                return modulus === 0 ? 0 : number - Math.floor(number / modulus) * modulus;
            },

            /**
             * Returns the fractional part of a specified number
             * @param {Number} number The number whose fractional part to compute.
             * @returns {Number} The fractional part of the specified number: number - floor(number).
             */
            fract: function (number) {
                return number - Math.floor(number);
            },

            /**
             * Returns the integer modulus of a specified number. This differs from the % operator in that
             * the result is always positive when the modulus is positive. For example -1 % 10 = -1,
             * whereas mod(-1, 10) = 1.
             * @param {Number} number The number whose modulus to compute.
             * @param {Number} modulus The modulus.
             * @returns {Number} The remainder after dividing the number by the modulus.
             */
            mod: function (number, modulus) {
                return ((number % modulus) + modulus) % modulus;
            },

            /**
             * Returns the maximum of two specified numbers.
             * @param {Number} value1 The first value to compare.
             * @param {Number} value2 The second value to compare.
             * @returns {Number} The maximum of the two specified values.
             */
            max: function (value1, value2) {
                return value1 > value2 ? value1 : value2;
            },

            /**
             * Computes the axes of a local coordinate system on the specified globe, placing the resultant axes in the specified
             * axis arguments.
             *
             * Upon return the specified axis arguments contain three orthogonal axes identifying the X, Y, and Z axes. Each
             * axis has unit length.
             *
             * The local coordinate system is defined such that the Z axis maps to the globe's surface normal at the point, the
             * Y axis maps to the north pointing tangent, and the X axis maps to the east pointing tangent.
             *
             * @param {Vec3} origin The local coordinate system origin, in model coordinates.
             * @param {Globe} globe The globe the coordinate system is relative to.
             * @param {Vec3} xAxisResult A pre-allocated Vec3 in which to return the computed X axis.
             * @param {Vec3} yAxisResult A pre-allocated Vec3 in which to return the computed Y axis.
             * @param {Vec3} zAxisResult A pre-allocated Vec3 in which to return the computed Z axis.
             * @throws {ArgumentError} If any argument is null or undefined.
             */
            localCoordinateAxesAtPoint: function (origin, globe, xAxisResult, yAxisResult, zAxisResult) {
                if (!origin) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "localCoordinateAxesAtPoint", "missingVector"));
                }

                if (!globe) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "localCoordinateAxesAtPoint", "missingGlobe"));
                }

                if (!xAxisResult || !yAxisResult || !zAxisResult) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "localCoordinateAxesAtPoint", "missingResult"));
                }

                var x = origin[0],
                    y = origin[1],
                    z = origin[2];

                // Compute the z axis from the surface normal in model coordinates. This axis is used to determine the other two
                // axes, and is the only constant in the computations below.
                globe.surfaceNormalAtPoint(x, y, z, zAxisResult);

                // Compute the y axis from the north pointing tangent in model coordinates. This axis is known to be orthogonal to
                // the z axis, and is therefore used to compute the x axis.
                globe.northTangentAtPoint(x, y, z, yAxisResult);

                // Compute the x axis as the cross product of the y and z axes. This ensures that the x and z axes are orthogonal.
                xAxisResult.set(yAxisResult[0], yAxisResult[1], yAxisResult[2]);
                xAxisResult.cross(zAxisResult);
                xAxisResult.normalize();

                // Re-compute the y axis as the cross product of the z and x axes. This ensures that all three axes are orthogonal.
                // Though the initial y axis computed above is likely to be very nearly orthogonal, we re-compute it using cross
                // products to reduce the effect of floating point rounding errors caused by working with Earth sized coordinates.
                yAxisResult.set(zAxisResult[0], zAxisResult[1], zAxisResult[2]);
                yAxisResult.cross(xAxisResult);
                yAxisResult.normalize();
            },

            /**
             * Computes the distance to a globe's horizon from a viewer at a given altitude.
             *
             * Only the globe's ellipsoid is considered; terrain height is not incorporated. This returns zero if the radius is zero
             * or if the altitude is less than or equal to zero.
             *
             * @param {Number} radius The globe's radius, in meters.
             * @param {Number} altitude The viewer's altitude above the globe, in meters.
             * @returns {Number} The distance to the horizon, in model coordinates.
             * @throws {ArgumentError} If the specified globe radius is negative.
             */
            horizonDistanceForGlobeRadius: function (radius, altitude) {
                if (radius &lt; 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "horizontalDistanceForGlobeRadius", "The specified globe radius is negative."));
                }

                return (radius > 0 &amp;&amp; altitude > 0) ? Math.sqrt(altitude * (2 * radius + altitude)) : 0;
            },

            /**
             * Computes the near clip distance that corresponds to a specified far clip distance and resolution at the far clip
             * plane.
             *
             * This computes a near clip distance appropriate for use in [perspectiveFrustumRect]{@link WWMath#perspectiveFrustumRectangle}
             * and [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection}. This returns zero if either the distance or the
             * resolution are zero.
             *
             * @param {Number} farDistance The far clip distance, in meters.
             * @param {Number} farResolution The depth resolution at the far clip plane, in meters.
             * @param {Number} depthBits The number of bit-planes in the depth buffer.
             * @returns {Number} The near clip distance, in meters.
             * @throws {ArgumentError} If either the distance or resolution is negative, or if the depth bits is less
             * than one.
             */
            perspectiveNearDistanceForFarDistance: function (farDistance, farResolution, depthBits) {
                if (farDistance &lt; 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
                        "The specified distance is negative."));
                }

                if (farResolution &lt; 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
                        "The specified resolution is negative."));
                }

                if (depthBits &lt; 1) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
                        "The specified depth bits is negative."));
                }

                var maxDepthValue = (1 &lt;&lt; depthBits) - 1;

                return farDistance / (maxDepthValue / (1 - farResolution / farDistance) - maxDepthValue + 1);
            },

            /**
             * Computes the maximum near clip distance for a perspective projection that avoids clipping an object at a
             * given distance from the eye point.
             * &lt;p/>
             * This computes a near clip distance appropriate for use in perspectiveFrustumRect and
             * Matrix.setToPerspectiveProjection. The given distance should specify the smallest distance between the
             * eye and the object being viewed, but may be an approximation if an exact distance is not required.
             *
             * @param {Number} viewportWidth The viewport width, in screen coordinates.
             * @param {Number} viewportHeight The viewport height, in screen coordinates.
             * @param {Number} distanceToSurface The distance from the perspective eye point to the nearest object, in
             * meters.
             * @returns {Number} The maximum near clip distance, in meters.
             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
             * specified distance is negative.
             */
            perspectiveNearDistance: function (viewportWidth, viewportHeight, distanceToSurface) {
                if (viewportWidth &lt;= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
                        "invalidWidth"));
                }

                if (viewportHeight &lt;= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
                        "invalidHeight"));
                }

                if (distanceToSurface &lt; 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
                        "The specified distance is negative."));
                }

                // Compute the maximum near clip distance that avoids clipping an object at the specified distance from
                // the eye. Since the furthest points on the near clip rectangle are the four corners, we compute a near
                // distance that puts any one of these corners exactly at the given distance. The distance to one of the
                // four corners can be expressed in terms of the near clip distance, given distance to a corner 'd',
                // near distance 'n', and aspect ratio 'a':
                //
                // d*d = x*x + y*y + z*z
                // d*d = (n*n/4 * a*a) + (n*n/4) + (n*n)
                //
                // Extracting 'n*n/4' from the right hand side gives:
                //
                // d*d = (n*n/4) * (a*a + 1 + 4)
                // d*d = (n*n/4) * (a*a + 5)
                //
                // Finally, solving for 'n' gives:
                //
                // n*n = 4 * d*d / (a*a + 5)
                // n = 2 * d / sqrt(a*a + 5)

                // Assumes a 45 degree horizontal field of view.
                var aspectRatio = viewportHeight / viewportWidth;

                return 2 * distanceToSurface / Math.sqrt(aspectRatio * aspectRatio + 5);
            },

            /**
             * Computes the coordinates of a rectangle carved out of a perspective projection's frustum at a given
             * distance in model coordinates. This returns an empty rectangle if the specified distance is zero.
             *
             * @param {Number} viewportWidth The viewport width, in screen coordinates.
             * @param {Number} viewportHeight The viewport height, in screen coordinates.
             * @param {Number} distance The distance along the negative Z axis, in model coordinates.
             * @returns {Rectangle} The frustum rectangle, in model coordinates.
             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
             * specified distance is negative.
             */
            perspectiveFrustumRectangle: function (viewportWidth, viewportHeight, distance) {
                if (viewportWidth &lt;= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
                        "invalidWidth"));
                }

                if (viewportHeight &lt;= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
                        "invalidHeight"));
                }

                if (distance &lt; 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
                        "The specified distance is negative."));
                }

                // Assumes a 45 degree horizontal field of view.
                var width = distance,
                    height = distance * viewportHeight / viewportWidth;

                return new Rectangle(-width / 2, -height / 2, width, height);
            },

            /**
             * Computes the vertical size of a pixel in model coordinates at a given distance from the eye point in a
             * perspective projection. This returns zero if the specified distance is zero. The returned size is
             * undefined if the distance is less than zero.
             * &lt;p/>
             * This method assumes the model of a screen composed of rectangular pixels, where pixel coordinates denote
             * infinitely thin space between pixels. The units of the returned size are in model coordinates per pixel
             * (usually meters per pixel).
             *
             * @param {Number} viewportWidth The viewport width, in screen coordinates.
             * @param {Number} viewportHeight The viewport height, in screen coordinates.
             * @param {Number} distance The distance from the perspective eye point at which to determine pixel size, in
             * model coordinates.
             * @returns {Number} The pixel size at the specified distance from the eye point, in model coordinates per
             * pixel.
             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
             * specified distance is negative.
             */
            perspectivePixelSize: function (viewportWidth, viewportHeight, distance) {
                if (viewportWidth &lt;= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
                        "invalidWidth"));
                }

                if (viewportHeight &lt;= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
                        "invalidHeight"));
                }

                if (distance &lt; 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
                        "The specified distance is negative."));
                }

                var frustumHeight = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, distance).height;
                return frustumHeight / viewportHeight;
            },

            /**
             * Computes the bounding rectangle for a unit quadrilateral after applying a transformation matrix to that
             * quadrilateral.
             * @param {Matrix} transformMatrix The matrix to apply to the unit quadrilateral.
             * @returns {Rectangle} The computed bounding rectangle.
             */
            boundingRectForUnitQuad: function (transformMatrix) {
                if (!transformMatrix) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "boundingRectForUnitQuad",
                        "missingMatrix"));
                }

                var m = transformMatrix,
                    // transform of (0, 0)
                    x1 = m[3],
                    y1 = m[7],
                    // transform of (1, 0)
                    x2 = m[0] + m[3],
                    y2 = m[4] + m[7],
                    // transform of (0, 1)
                    x3 = m[1] + m[3],
                    y3 = m[5] + m[7],
                    // transform of (1, 1)
                    x4 = m[0] + m[1] + m[3],
                    y4 = m[4] + m[5] + m[7],
                    minX = Math.min(Math.min(x1, x2), Math.min(x3, x4)),
                    maxX = Math.max(Math.max(x1, x2), Math.max(x3, x4)),
                    minY = Math.min(Math.min(y1, y2), Math.min(y3, y4)),
                    maxY = Math.max(Math.max(y1, y2), Math.max(y3, y4));

                return new Rectangle(minX, minY, maxX - minX, maxY - minY);
            },

            /**
             * Indicates whether a specified value is a power of two.
             * @param {Number} value The value to test.
             * @returns {boolean} &lt;code>true&lt;/code> if the specified value is a power of two,
             * otherwise &lt;code>false&lt;/code>.
             */
            isPowerOfTwo: function (value) {
                return value != 0 &amp;&amp; (value &amp; (value - 1)) === 0;
            },

            /**
             * Determine the sign of a number.
             * @param {Number} value The value to determine the sign of.
             * @returns {Number} 1, -1, or 0, depending on the sign of the value.
             */
            signum: function (value) {
                return value > 0 ? 1 : value &lt; 0 ? -1 : 0;
            },

            /**
             * Calculates the Gudermannian inverse used to unproject Mercator projections.
             * @param {Number} latitude The latitude in degrees.
             * @returns {Number} The Gudermannian inverse for the specified latitude.
             */
            gudermannianInverse: function (latitude) {
                return Math.log(Math.tan(Math.PI / 4 + (latitude * Angle.DEGREES_TO_RADIANS) / 2)) / Math.PI;
            },

            epsg3857ToEpsg4326: function (easting, northing) {
                var r = 6.3781e6,
                    latRadians = (Math.PI / 2) - 2 * Math.atan(Math.exp(-northing / r)),
                    lonRadians = easting / r;

                return [
                    WWMath.clamp(latRadians * Angle.RADIANS_TO_DEGREES, -90, 90),
                    WWMath.clamp(lonRadians * Angle.RADIANS_TO_DEGREES, -180, 180)
                ];
            },

            /**
             * Returns the value that is the nearest power of 2 less than or equal to the given value.
             * @param {Number} value the reference value. The power of 2 returned is less than or equal to this value.
             * @returns {Number} the value that is the nearest power of 2 less than or equal to the reference value
             */
            powerOfTwoFloor: function (value) {
                var power = Math.floor(Math.log(value) / Math.log(2));
                return Math.pow(2, power);
            },

            /**
             * Restricts an angle to the range [0, 360] degrees, wrapping angles outside the range.
             * Wrapping takes place as though traversing the edge of a unit circle;
             * angles less than 0 wrap back to 360, while angles greater than 360 wrap back to 0.
             *
             * @param {Number} degrees the angle to wrap in degrees
             *
             * @return {Number} the specified angle wrapped to [0, 360] degrees
             */
            normalizeAngle360: function (degrees) {
                var angle = degrees % 360;
                return angle >= 0 ? angle : (angle &lt; 0 ? 360 + angle : 360 - angle);
            }
        };

        return WWMath;
    });</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-AAIGridConstants.html">AAIGridConstants</a></li><li><a href="module-Angle.html">Angle</a></li><li><a href="module-ColladaUtils.html">ColladaUtils</a></li><li><a href="module-GeoJSONExporter.html">GeoJSONExporter</a></li><li><a href="module-HeatMapIntervalType.html">HeatMapIntervalType</a></li><li><a href="module-KmlElements.html">KmlElements</a></li><li><a href="module-KmlFileCache.html">KmlFileCache</a></li><li><a href="module-KmlNodeTransformers.html">KmlNodeTransformers</a></li><li><a href="module-KmlStyleResolver.html">KmlStyleResolver</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-MeasurerUtils.html">MeasurerUtils</a></li><li><a href="module-PolygonSplitter.html">PolygonSplitter</a></li><li><a href="module-SunPosition.html">SunPosition</a></li><li><a href="module-WktElements.html">WktElements</a></li><li><a href="module-WktExporter.html">WktExporter</a></li><li><a href="module-WorldWind.html">WorldWind</a></li><li><a href="module-WWMath.html">WWMath</a></li><li><a href="module-WWUtil.html">WWUtil</a></li></ul><h3>Classes</h3><ul><li><a href="AAIGridMetadata.html">AAIGridMetadata</a></li><li><a href="AAIGridReader.html">AAIGridReader</a></li><li><a href="AbsentResourceList.html">AbsentResourceList</a></li><li><a href="AbstractError.html">AbstractError</a></li><li><a href="AbstractMesh.html">AbstractMesh</a></li><li><a href="AbstractShape.html">AbstractShape</a></li><li><a href="Annotation.html">Annotation</a></li><li><a href="AnnotationAttributes.html">AnnotationAttributes</a></li><li><a href="AreaMeasurer.html">AreaMeasurer</a></li><li><a href="ArgumentError.html">ArgumentError</a></li><li><a href="AsterV2ElevationCoverage.html">AsterV2ElevationCoverage</a></li><li><a href="AtmosphereLayer.html">AtmosphereLayer</a></li><li><a href="AtmosphereProgram.html">AtmosphereProgram</a></li><li><a href="BasicProgram.html">BasicProgram</a></li><li><a href="BasicTextureProgram.html">BasicTextureProgram</a></li><li><a href="BasicTimeSequence.html">BasicTimeSequence</a></li><li><a href="BasicWorldWindowController.html">BasicWorldWindowController</a></li><li><a href="BingAerialLayer.html">BingAerialLayer</a></li><li><a href="BingAerialWithLabelsLayer.html">BingAerialWithLabelsLayer</a></li><li><a href="BingImageryUrlBuilder.html">BingImageryUrlBuilder</a></li><li><a href="BingRoadsLayer.html">BingRoadsLayer</a></li><li><a href="BingTiledImageLayer.html">BingTiledImageLayer</a></li><li><a href="BMNGLandsatLayer.html">BMNGLandsatLayer</a></li><li><a href="BMNGLayer.html">BMNGLayer</a></li><li><a href="BMNGOneImageLayer.html">BMNGOneImageLayer</a></li><li><a href="BMNGRestLayer.html">BMNGRestLayer</a></li><li><a href="BoundingBox.html">BoundingBox</a></li><li><a href="ByteBuffer.html">ByteBuffer</a></li><li><a href="ClickRecognizer.html">ClickRecognizer</a></li><li><a href="ColladaAsset.html">ColladaAsset</a></li><li><a href="ColladaImage.html">ColladaImage</a></li><li><a href="ColladaLoader.html">ColladaLoader</a></li><li><a href="ColladaMaterial.html">ColladaMaterial</a></li><li><a href="ColladaMesh.html">ColladaMesh</a></li><li><a href="ColladaNode.html">ColladaNode</a></li><li><a href="ColladaScene.html">ColladaScene</a></li><li><a href="Color.html">Color</a></li><li><a href="Compass.html">Compass</a></li><li><a href="CompassLayer.html">CompassLayer</a></li><li><a href="CoordinatesDisplayLayer.html">CoordinatesDisplayLayer</a></li><li><a href="DateWW.html">DateWW</a></li><li><a href="DBaseFile.html">DBaseFile</a></li><li><a href="DigitalGlobeTiledImageLayer.html">DigitalGlobeTiledImageLayer</a></li><li><a href="DragRecognizer.html">DragRecognizer</a></li><li><a href="DrawContext.html">DrawContext</a></li><li><a href="EarthElevationModel.html">EarthElevationModel</a></li><li><a href="EarthRestElevationCoverage.html">EarthRestElevationCoverage</a></li><li><a href="ElevationCoverage.html">ElevationCoverage</a></li><li><a href="ElevationImage.html">ElevationImage</a></li><li><a href="ElevationModel.html">ElevationModel</a></li><li><a href="Font.html">Font</a></li><li><a href="FramebufferTexture.html">FramebufferTexture</a></li><li><a href="FramebufferTile.html">FramebufferTile</a></li><li><a href="FramebufferTileController.html">FramebufferTileController</a></li><li><a href="FrameStatistics.html">FrameStatistics</a></li><li><a href="FrameStatisticsLayer.html">FrameStatisticsLayer</a></li><li><a href="Frustum.html">Frustum</a></li><li><a href="GebcoElevationCoverage.html">GebcoElevationCoverage</a></li><li><a href="GeographicMesh.html">GeographicMesh</a></li><li><a href="GeographicProjection.html">GeographicProjection</a></li><li><a href="GeographicText.html">GeographicText</a></li><li><a href="GeoJSONConstants.html">GeoJSONConstants</a></li><li><a href="GeoJSONCRS.html">GeoJSONCRS</a></li><li><a href="GeoJSONFeature.html">GeoJSONFeature</a></li><li><a href="GeoJSONFeatureCollection.html">GeoJSONFeatureCollection</a></li><li><a href="GeoJSONGeometry.html">GeoJSONGeometry</a></li><li><a href="GeoJSONGeometryCollection.html">GeoJSONGeometryCollection</a></li><li><a href="GeoJSONGeometryLineString.html">GeoJSONGeometryLineString</a></li><li><a href="GeoJSONGeometryMultiLineString.html">GeoJSONGeometryMultiLineString</a></li><li><a href="GeoJSONGeometryMultiPoint.html">GeoJSONGeometryMultiPoint</a></li><li><a href="GeoJSONGeometryMultiPolygon.html">GeoJSONGeometryMultiPolygon</a></li><li><a href="GeoJSONGeometryPoint.html">GeoJSONGeometryPoint</a></li><li><a href="GeoJSONGeometryPolygon.html">GeoJSONGeometryPolygon</a></li><li><a href="GeoJSONParser.html">GeoJSONParser</a></li><li><a href="GeoTiff.html">GeoTiff</a></li><li><a href="GeoTiffKeyEntry.html">GeoTiffKeyEntry</a></li><li><a href="GeoTiffMetadata.html">GeoTiffMetadata</a></li><li><a href="GeoTiffReader.html">GeoTiffReader</a></li><li><a href="GestureRecognizer.html">GestureRecognizer</a></li><li><a href="Globe.html">Globe</a></li><li><a href="Globe2D.html">Globe2D</a></li><li><a href="GoToAnimator.html">GoToAnimator</a></li><li><a href="GpuProgram.html">GpuProgram</a></li><li><a href="GpuResourceCache.html">GpuResourceCache</a></li><li><a href="GpuShader.html">GpuShader</a></li><li><a href="GroundProgram.html">GroundProgram</a></li><li><a href="HashMap.html">HashMap</a></li><li><a href="HeatMapColoredTile.html">HeatMapColoredTile</a></li><li><a href="HeatMapLayer.html">HeatMapLayer</a></li><li><a href="HeatMapTile.html">HeatMapTile</a></li><li><a href="HighlightController.html">HighlightController</a></li><li><a href="ImageSource.html">ImageSource</a></li><li><a href="ImageTile.html">ImageTile</a></li><li><a href="Insets.html">Insets</a></li><li><a href="KmlAbstractView.html">KmlAbstractView</a></li><li><a href="KmlAttribute.html">KmlAttribute</a></li><li><a href="KmlBalloonStyle.html">KmlBalloonStyle</a></li><li><a href="KmlCamera.html">KmlCamera</a></li><li><a href="KmlChange.html">KmlChange</a></li><li><a href="KmlColorStyle.html">KmlColorStyle</a></li><li><a href="KmlContainer.html">KmlContainer</a></li><li><a href="KmlControls.html">KmlControls</a></li><li><a href="KmlCreate.html">KmlCreate</a></li><li><a href="KmlDelete.html">KmlDelete</a></li><li><a href="KmlDocument.html">KmlDocument</a></li><li><a href="KmlElementsFactory.html">KmlElementsFactory</a></li><li><a href="KmlElementsFactoryCached.html">KmlElementsFactoryCached</a></li><li><a href="KmlFeature.html">KmlFeature</a></li><li><a href="KmlFile.html">KmlFile</a></li><li><a href="KmlFolder.html">KmlFolder</a></li><li><a href="KmlGeometry.html">KmlGeometry</a></li><li><a href="KmlGroundOverlay.html">KmlGroundOverlay</a></li><li><a href="KmlHrefResolver.html">KmlHrefResolver</a></li><li><a href="KmlIcon.html">KmlIcon</a></li><li><a href="KmlIconStyle.html">KmlIconStyle</a></li><li><a href="KmlImagePyramid.html">KmlImagePyramid</a></li><li><a href="KmlItemIcon.html">KmlItemIcon</a></li><li><a href="KmlLabelStyle.html">KmlLabelStyle</a></li><li><a href="KmlLatLonAltBox.html">KmlLatLonAltBox</a></li><li><a href="KmlLatLonBox.html">KmlLatLonBox</a></li><li><a href="KmlLatLonQuad.html">KmlLatLonQuad</a></li><li><a href="KmlLinearRing.html">KmlLinearRing</a></li><li><a href="KmlLineString.html">KmlLineString</a></li><li><a href="KmlLineStyle.html">KmlLineStyle</a></li><li><a href="KmlLink.html">KmlLink</a></li><li><a href="KmlListStyle.html">KmlListStyle</a></li><li><a href="KmlLocation.html">KmlLocation</a></li><li><a href="KmlLod.html">KmlLod</a></li><li><a href="KmlLookAt.html">KmlLookAt</a></li><li><a href="KmlMultiGeometry.html">KmlMultiGeometry</a></li><li><a href="KmlMultiTrack.html">KmlMultiTrack</a></li><li><a href="KmlNetworkLink.html">KmlNetworkLink</a></li><li><a href="KmlNetworkLinkControl.html">KmlNetworkLinkControl</a></li><li><a href="KmlObject.html">KmlObject</a></li><li><a href="KmlOrientation.html">KmlOrientation</a></li><li><a href="KmlOverlay.html">KmlOverlay</a></li><li><a href="KmlPair.html">KmlPair</a></li><li><a href="KmlPhotoOverlay.html">KmlPhotoOverlay</a></li><li><a href="KmlPlacemark.html">KmlPlacemark</a></li><li><a href="KmlPoint.html">KmlPoint</a></li><li><a href="KmlPolygon.html">KmlPolygon</a></li><li><a href="KmlPolyStyle.html">KmlPolyStyle</a></li><li><a href="KmlRefreshListener.html">KmlRefreshListener</a></li><li><a href="KmlRefreshListener.Event.html">Event</a></li><li><a href="KmlRegion.html">KmlRegion</a></li><li><a href="KmlRemoteFile.html">KmlRemoteFile</a></li><li><a href="KmlScale.html">KmlScale</a></li><li><a href="KmlSchema.html">KmlSchema</a></li><li><a href="KmlScreenOverlay.html">KmlScreenOverlay</a></li><li><a href="KmlStyle.html">KmlStyle</a></li><li><a href="KmlStyleMap.html">KmlStyleMap</a></li><li><a href="KmlStyleSelector.html">KmlStyleSelector</a></li><li><a href="KmlSubStyle.html">KmlSubStyle</a></li><li><a href="KmlTimePrimitive.html">KmlTimePrimitive</a></li><li><a href="KmlTimeSpan.html">KmlTimeSpan</a></li><li><a href="KmlTimeStamp.html">KmlTimeStamp</a></li><li><a href="KmlTour.html">KmlTour</a></li><li><a href="KmlTrack.html">KmlTrack</a></li><li><a href="KmlTreeKeyValueCache.html">KmlTreeKeyValueCache</a></li><li><a href="KmlTreeVisibility.html">KmlTreeVisibility</a></li><li><a href="KmlViewVolume.html">KmlViewVolume</a></li><li><a href="KmzFile.html">KmzFile</a></li><li><a href="LandsatRestLayer.html">LandsatRestLayer</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LengthMeasurer.html">LengthMeasurer</a></li><li><a href="Level.html">Level</a></li><li><a href="LevelRowColumnUrlBuilder.html">LevelRowColumnUrlBuilder</a></li><li><a href="libtess.ActiveRegion.html">ActiveRegion</a></li><li><a href="libtess.CachedVertex.html">CachedVertex</a></li><li><a href="libtess.Dict.html">Dict</a></li><li><a href="libtess.DictNode.html">DictNode</a></li><li><a href="libtess.GluFace.html">GluFace</a></li><li><a href="libtess.GluHalfEdge.html">GluHalfEdge</a></li><li><a href="libtess.GluMesh.html">GluMesh</a></li><li><a href="libtess.GluTesselator.html">GluTesselator</a></li><li><a href="libtess.GluVertex.html">GluVertex</a></li><li><a href="libtess.PQHandleElem.html">PQHandleElem</a></li><li><a href="libtess.PQNode.html">PQNode</a></li><li><a href="libtess.PriorityQ.html">PriorityQ</a></li><li><a href="libtess.PriorityQHeap.html">PriorityQHeap</a></li><li><a href="Line.html">Line</a></li><li><a href="Location.html">Location</a></li><li><a href="LookAtNavigator.html">LookAtNavigator</a></li><li><a href="Matrix.html">Matrix</a></li><li><a href="Matrix3.html">Matrix3</a></li><li><a href="MeasuredLocation.html">MeasuredLocation</a></li><li><a href="MemoryCache.html">MemoryCache</a></li><li><a href="MemoryCacheListener.html">MemoryCacheListener</a></li><li><a href="MercatorTiledImageLayer.html">MercatorTiledImageLayer</a></li><li><a href="Navigator.html">Navigator</a></li><li><a href="NominatimGeocoder.html">NominatimGeocoder</a></li><li><a href="NotYetImplementedError.html">NotYetImplementedError</a></li><li><a href="Offset.html">Offset</a></li><li><a href="OpenStreetMapImageLayer.html">OpenStreetMapImageLayer</a></li><li><a href="OrderedRenderable.html">OrderedRenderable</a></li><li><a href="OwsConstraint.html">OwsConstraint</a></li><li><a href="OwsDescription.html">OwsDescription</a></li><li><a href="OwsLanguageString.html">OwsLanguageString</a></li><li><a href="OwsOperationsMetadata.html">OwsOperationsMetadata</a></li><li><a href="OwsServiceIdentification.html">OwsServiceIdentification</a></li><li><a href="OwsServiceProvider.html">OwsServiceProvider</a></li><li><a href="PanRecognizer.html">PanRecognizer</a></li><li><a href="Path.html">Path</a></li><li><a href="PeriodicTimeSequence.html">PeriodicTimeSequence</a></li><li><a href="PickedObject.html">PickedObject</a></li><li><a href="PickedObjectList.html">PickedObjectList</a></li><li><a href="PinchRecognizer.html">PinchRecognizer</a></li><li><a href="Placemark.html">Placemark</a></li><li><a href="PlacemarkAttributes.html">PlacemarkAttributes</a></li><li><a href="Plane.html">Plane</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="Position.html">Position</a></li><li><a href="PrjFile.html">PrjFile</a></li><li><a href="ProjectionEquirectangular.html">ProjectionEquirectangular</a></li><li><a href="ProjectionGnomonic.html">ProjectionGnomonic</a></li><li><a href="ProjectionMercator.html">ProjectionMercator</a></li><li><a href="ProjectionPolarEquidistant.html">ProjectionPolarEquidistant</a></li><li><a href="ProjectionUPS.html">ProjectionUPS</a></li><li><a href="ProjectionWgs84.html">ProjectionWgs84</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="Renderable.html">Renderable</a></li><li><a href="RenderableLayer.html">RenderableLayer</a></li><li><a href="RestTiledImageLayer.html">RestTiledImageLayer</a></li><li><a href="RotationRecognizer.html">RotationRecognizer</a></li><li><a href="ScreenCreditController.html">ScreenCreditController</a></li><li><a href="ScreenImage.html">ScreenImage</a></li><li><a href="ScreenText.html">ScreenText</a></li><li><a href="Sector.html">Sector</a></li><li><a href="ShapeAttributes.html">ShapeAttributes</a></li><li><a href="Shapefile.html">Shapefile</a></li><li><a href="ShapefileRecord.html">ShapefileRecord</a></li><li><a href="ShapefileRecordMultiPoint.html">ShapefileRecordMultiPoint</a></li><li><a href="ShapefileRecordNull.html">ShapefileRecordNull</a></li><li><a href="ShapefileRecordPoint.html">ShapefileRecordPoint</a></li><li><a href="ShapefileRecordPolygon.html">ShapefileRecordPolygon</a></li><li><a href="ShapefileRecordPolyline.html">ShapefileRecordPolyline</a></li><li><a href="SkyProgram.html">SkyProgram</a></li><li><a href="StarFieldLayer.html">StarFieldLayer</a></li><li><a href="StarFieldProgram.html">StarFieldProgram</a></li><li><a href="SurfaceCircle.html">SurfaceCircle</a></li><li><a href="SurfaceEllipse.html">SurfaceEllipse</a></li><li><a href="SurfaceImage.html">SurfaceImage</a></li><li><a href="SurfacePolygon.html">SurfacePolygon</a></li><li><a href="SurfacePolyline.html">SurfacePolyline</a></li><li><a href="SurfaceRectangle.html">SurfaceRectangle</a></li><li><a href="SurfaceRenderable.html">SurfaceRenderable</a></li><li><a href="SurfaceSector.html">SurfaceSector</a></li><li><a href="SurfaceShape.html">SurfaceShape</a></li><li><a href="SurfaceShapeTile.html">SurfaceShapeTile</a></li><li><a href="SurfaceTile.html">SurfaceTile</a></li><li><a href="SurfaceTileRenderer.html">SurfaceTileRenderer</a></li><li><a href="SurfaceTileRendererProgram.html">SurfaceTileRendererProgram</a></li><li><a href="TapRecognizer.html">TapRecognizer</a></li><li><a href="TectonicPlatesLayer.html">TectonicPlatesLayer</a></li><li><a href="Terrain.html">Terrain</a></li><li><a href="TerrainTile.html">TerrainTile</a></li><li><a href="TerrainTileList.html">TerrainTileList</a></li><li><a href="Tessellator.html">Tessellator</a></li><li><a href="Text.html">Text</a></li><li><a href="TextAttributes.html">TextAttributes</a></li><li><a href="TextRenderer.html">TextRenderer</a></li><li><a href="Texture.html">Texture</a></li><li><a href="TextureTile.html">TextureTile</a></li><li><a href="TiffConstants.html">TiffConstants</a></li><li><a href="TiffIFDEntry.html">TiffIFDEntry</a></li><li><a href="Tile.html">Tile</a></li><li><a href="TiledElevationCoverage.html">TiledElevationCoverage</a></li><li><a href="TiledImageLayer.html">TiledImageLayer</a></li><li><a href="TileFactory.html">TileFactory</a></li><li><a href="TiltRecognizer.html">TiltRecognizer</a></li><li><a href="Touch.html">Touch</a></li><li><a href="TriangleMesh.html">TriangleMesh</a></li><li><a href="UnsupportedOperationError.html">UnsupportedOperationError</a></li><li><a href="UrlBuilder.html">UrlBuilder</a></li><li><a href="UsgsNedElevationCoverage.html">UsgsNedElevationCoverage</a></li><li><a href="UsgsNedHiElevationCoverage.html">UsgsNedHiElevationCoverage</a></li><li><a href="Vec2.html">Vec2</a></li><li><a href="Vec3.html">Vec3</a></li><li><a href="ViewControlsLayer.html">ViewControlsLayer</a></li><li><a href="WcsCapabilities.html">WcsCapabilities</a></li><li><a href="WcsCoverageDescriptions.html">WcsCoverageDescriptions</a></li><li><a href="WcsEarthElevationCoverage.html">WcsEarthElevationCoverage</a></li><li><a href="WcsTileUrlBuilder.html">WcsTileUrlBuilder</a></li><li><a href="WFSCapabilities.html">WFSCapabilities</a></li><li><a href="Wkt.html">Wkt</a></li><li><a href="WktGeometryCollection.html">WktGeometryCollection</a></li><li><a href="WktLineString.html">WktLineString</a></li><li><a href="WktMultiLineString.html">WktMultiLineString</a></li><li><a href="WktMultiPoint.html">WktMultiPoint</a></li><li><a href="WktMultiPolygon.html">WktMultiPolygon</a></li><li><a href="WktObject.html">WktObject</a></li><li><a href="WktPoint.html">WktPoint</a></li><li><a href="WktPolygon.html">WktPolygon</a></li><li><a href="WktTriangle.html">WktTriangle</a></li><li><a href="WktType.html">WktType</a></li><li><a href="WMSCapabilities.html">WMSCapabilities</a></li><li><a href="WmsLayer.html">WmsLayer</a></li><li><a href="WmsLayerCapabilities.html">WmsLayerCapabilities</a></li><li><a href="WmsTimeDimensionedLayer.html">WmsTimeDimensionedLayer</a></li><li><a href="WmsUrlBuilder.html">WmsUrlBuilder</a></li><li><a href="WmtsCapabilities.html">WmtsCapabilities</a></li><li><a href="WmtsLayer.html">WmtsLayer</a></li><li><a href="WmtsLayerCapabilities.html">WmtsLayerCapabilities</a></li><li><a href="WorldWindow.html">WorldWindow</a></li><li><a href="WorldWindowController.html">WorldWindowController</a></li></ul><h3>Global</h3><ul><li><a href="global.html#catch">catch</a></li><li><a href="global.html#crs">crs</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#maxElevation">maxElevation</a></li><li><a href="global.html#minElevation">minElevation</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#then">then</a></li><li><a href="global.html#timestamp">timestamp</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Tue Apr 06 2021 10:24:41 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
